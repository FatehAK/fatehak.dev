---
date: '2023-02-19T07:46:15.235Z'
lastMod: '2023-02-20T20:19:56.364Z'
title: Automate dependency updates with Renovate
seoTitle: Automate your dependency updates with Renovate
highlight: Renovate
description: >-
  Dependencies go out-of-date rapidly and keeping track of them is even more
  tiring. Learn how Renovate can help you in your dependency automation journey.
tags:
  - tooling
---
import onboardPRImage from 'assets/posts/automate-dependency-updates-renovate/onboard-pr.png';
import depUpdatePrImage from 'assets/posts/automate-dependency-updates-renovate/dep-update-pr.png';
import depDashImage from 'assets/posts/automate-dependency-updates-renovate/dep-dash.png';
import depDashApprovalImage from 'assets/posts/automate-dependency-updates-renovate/dep-dash-approval.png';

Every modern web project has a plethora of **dependencies** bundled together. It may not seem much initially, but managing dependencies becomes a project's greatest maintenance nightmare in the long run.

The hard truth is dependencies go **out-of-date** rapidly, with patches and minor releases coming out every other week. It is important to keep them updated continuously rather than deferring this activity for later every time. The added advantage is that updates could bring potential bug fixes and patches for critical security vulnerabilities. (or introduce new ones as well, we'll see how we can tackle this later in the article)

Developers dread getting assigned a dependency updation task, and this is true when it's been ages since you've last done it or you are totally out of loop of any changes.

We should leverage the tools available to solve such problems. [Renovate](https://www.mend.io/free-developer-tools/renovate/) is one such tool that does the job swimmingly!

## Setup Renovate

Let's take a look at setting it up. There are two ways to set up Renovate:

- Self-Hosting the service
- Using the built-in GitHub / GitLab app

Usually, self-hosting would be the better approach for private projects, but as my use case already revolved around projects hosted on GitHub, we'll take that route instead.

You can add the [GitHub app](https://github.com/marketplace/renovate) from the marketplace and give it access to your repository of choice.

Renovate will create an onboarding PR shortly to merge a `renovate.json` configuration file into your repository.

<Figure alt="Onboarding PR created by Renovate Bot" src={onboardPRImage}>
  Onboarding PR created by Renovate Bot
</Figure>

A basic configuration file is created at the repository `<root>` with the onboarding PR.

```json title="renovate.json"
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:base"]
}
```

Renovate will now scan your `package.json` for dependencies. The default update style is through PRs which are raised for all `dependencies`, `devDependencies`, and `peerDependencies`. (we will see later how we can customize this)

<Figure alt="Onboarding PR created by Renovate Bot" src={depUpdatePrImage}>
  Renovate raised a PR automatically to update eslint-plugin-import :partying_face:
</Figure>

A PR is raised with details such as **release notes**, **age**, **adoption rate**, and more for every dependency. These details can help us make an informed decision and ensures we stay in the loop if there are any breaking changes or vulnerabilities.

Supported package managers include [npm](https://www.npmjs.com/), [yarn](https://yarnpkg.com/), and [pnpm](https://pnpm.io/), so your `lock` files will be kept in sync with the updates too.

The **customizability** part is where it really shines. Let's check out some ways to make it even more seamless.

## Schedules

You can set **schedules** to tell Renovate when to run the updates.

An example schedule looks like below:

```json
"schedule": ["before 11am every saturday"]
```

Renovate uses the UTC timezone by default which you can override:

```json
"timezone": "Asia/Kolkata"
```

You can also set Renovate to **rebase automatically** whenever it's behind the base branch to avoid potential merge conflicts. It can come in handy when we are running it on a schedule.

```json
"rebaseWhen": "behind-base-branch"
```

Scheduling has helped me stay on top of updates, as I know precisely when the updates will be raised which makes me plan better for that day.

Refer to the documentation on [schedules](https://docs.renovatebot.com/key-concepts/scheduling/) to learn more about the syntax.

## Grouping updates

Let's consider we have **10 dependencies** that need to be updated. Renovate will see this and raise **10 PRs** on your branch. A better approach is to group dependency updates that belong together.

You can think of creating meaningful groups. For example, you can group all updates to **eslint** and its plugins in a single PR.

```json {4}
{
  "packageRules": [
    {
      "matchPackagePatterns": ["^eslint"],
      "groupName": "eslint and its plugins",
      "groupSlug": "eslint"
    }
  ]
}
```

Or you could create a generic group of `minor` and `patch` releases for all dependencies. Now, all updates for the group happen in a single PR.

```json
{
  "patch": {
    "groupName": "non-major dependencies",
    "groupSlug": "minor-patch"
  },
  "minor": {
    "groupName": "non-major dependencies",
    "groupSlug": "minor-patch"
  }
}
```

Think deeply as to which dependencies belong together. There could be some you know that are always used together, for example, build-time dependencies used for image compression.

> ;info;
> **Note**: One caveat here is to be careful with the grouping strategy. If a dependency part of a larger group breaks, it may be a while before you figure it out.

## Automerge

By default, Renovate raises a PR that must be manually reviewed and merged. While this flow is ideal for any critical dependencies and updates to major versions but for devDependencies or any trivial ones, this will slow you down.

For dependencies you are super confident about, you can configure Renovate to automerge the PRs.

```json
{
  "packageRules": [
    {
      "matchUpdateTypes": ["minor", "patch"],
      "matchPackageNames": ["rimraf"],
      "automerge": true
    }
  ]
}
```

The above snippet will automerge PRs for the **rimraf** package only for `minor` and `patch` releases, but for `major` releases, you must merge the PR manually.

You can even tell Renovate to **automerge a branch** instead of a PR. Whenever a PR gets merged on GitHub, you get an annoying email adding noise to your mailbox.

To avoid it, we can tell Renovate to create a temporary branch instead and merge it automatically and silently in ninja style!

```json {3}
{
  "automerge": true,
  "automergeType": "branch",
  "automergeStrategy": "rebase",
  "commitBodyTable": true
}
```

You can avoid merge commits by passing `rebase` as the automerge strategy.

In the `branch` strategy, details such as release notes and adoption rates are missing because these are generated only for PRs. So, we can set the `commitBodyTable` flag to at least get the bare minimum details.

<div class="table-wrap">
  | datasource | package     | from   | to     |
  | ---------- | ----------- | ------ | ------ |
  | npm        | lint-staged | 13.1.0 | 13.1.1 |
  | npm        | rimraf      | 3.1.0  | 3.1.1  |
</div>

Renovate creates branches with the prefix `renovate/`, so you can configure your **CI** to run relevant tests and build jobs on it before it gets merged.

On a GitHub repository, Renovate requires all status checks to be passing before the merge happens, regardless you can bypass this:

```json
{
  "ignoreTests": "true"
}
```

> ;info;
> **Caution**: Use the automerge feature only when you are **confident** of your CI pipeline and set it up to avoid critical dependencies and `major` releases.

Learn more about [automerge](https://docs.renovatebot.com/key-concepts/automerge/) on Renovate's official docs.

## Dependency Dashboard

The Dependency Dashboard is one of the coolest features of Renovate. If enabled, Renovate creates an `issue` in your repository containing the status of all your dependencies about to be merged, and this works nicely when automerge and scheduling are enabled.

<Figure alt="Onboarding PR created by Renovate Bot" src={depDashImage}>
  Dependency Dashboard listing all pending updates
</Figure>

To enable it:

```json
{
  "dependencyDashboard": true
}
```

An additional feature supported by the Dashboard is **package approval**. For example, if you have automerge enabled, you can tell Renovate that all `major` dependencies need to be approved first before are automerged.

<Figure alt="Onboarding PR created by Renovate Bot" src={depDashApprovalImage}>
  All <code>major</code> dependencies require approval
</Figure>

You can configure it like so:

```json
{
  "major": {
    "dependencyDashboardApproval": true
  }
}
```

Or you can even tell it require approval only for certain packages:

```json
{
  "packageRules": [
    {
      "matchPackagePatterns": ["^my-package"],
      "dependencyDashboardApproval": true,
    }
  ]
}
```

Note that not all platforms support this feature. Here is an excerpt from the Renovate docs:

> The Dependency Dashboard requires that the host platforms supports the concept of issues with dynamic Markdown checkboxes.

Learn more about the [dashboard](https://docs.renovatebot.com/key-concepts/dashboard/) in the docs.

## My Configuration

I've set up Renovate for some of my projects and NPM packages. My main focus was on reducing PR noise and simplicity.

Scheduling is set for **before 11am every saturday** with `branch` auto merges and package groups set up for `minor + patch` and `major` versions. The dashboard approval flow is set for all `major` versions.

```json {5,10,14,20-27,31-36} showLineNumbers title="renovate.json"
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": ["config:base"],
  "labels": ["dependencies"],
  "schedule": ["before 11am every saturday"],
  "timezone": "Asia/Kolkata",
  "enabledManagers": ["npm"],
  "rangeStrategy": "bump",
  "automerge": true,
  "automergeType": "branch",
  "automergeStrategy": "rebase",
  "commitMessagePrefix": "chore(deps): ",
  "commitBodyTable": true,
  "dependencyDashboard": true,
  "dependencyDashboardAutoclose": true,
  "configMigration": true,
  "platformCommit": true,
  "lockFileMaintenance": { "enabled": true },
  "rebaseWhen": "behind-base-branch",
  "patch": {
    "groupName": "non-major dependencies",
    "groupSlug": "minor-patch"
  },
  "minor": {
    "groupName": "non-major dependencies",
    "groupSlug": "minor-patch"
  },
  "vulnerabilityAlerts": {
    "labels": ["security"]
  },
  "major": {
    "automerge": false,
    "dependencyDashboardApproval": true,
    "commitMessagePrefix": "chore(deps-major): ",
    "labels": ["dependencies", "breaking"]
  },
  "packageRules": [
    {
      "matchPackageNames": ["node"],
      "enabled": false
    },
    {
      "matchDepTypes": ["peerDependencies"],
      "enabled": false
    }
  ]
}
```

Some additional things include disabling the auto-updation of `peerDependencies` and the Node version since updating them can be problematic for other dependencies.

> ;info;
> **Renovate is not limited to Node alone!** You can add support for additional managers like dockerfile, pip, gomod, etc through the `enabledManagers` property. Check out all [supported managers](https://docs.renovatebot.com/modules/manager/#supported-managers) in the docs.

With this configuration, I take one quick look at Renovate's dashboard early morning on Saturday while having my hot cup of coffee and approve requests seamlessly. And this is precisely the kind of automation I was looking for :sparkles:

<SlashLine />

## Wrapping up

Renovate is free, feature-packed, has a regular maintenance schedule, and is used globally by several top-tier [companies](https://github.com/renovatebot/renovate#who-uses-renovate).

I enjoy automating things like this. I used to constantly think about what would happen to my projects given the rapidly changing state of the Web. This is what led me to Renovate. In a way, it has helped me stay on top of the latest advancements. I consider it a prerequisite now for setting up any new project.

This article only touched the tip of an iceberg, do check out its super detailed [docs](https://docs.renovatebot.com/) to learn more. You can also check out my [repository](https://github.com/FatehAK/vite-plugin-image-optimizer) as a reference.

So, what are you waiting for? Time to get automatin! :rocket:

<Feedback />

---
